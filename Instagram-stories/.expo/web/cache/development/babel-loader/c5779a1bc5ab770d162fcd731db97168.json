{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport invariant from 'fbjs/lib/invariant';\n\nfunction createStrictShapeTypeChecker(shapeTypes) {\n  function checkType(isRequired, props, propName, componentName, location) {\n    if (!props[propName]) {\n      if (isRequired) {\n        invariant(false, \"Required object `\" + propName + \"` was not specified in `\" + componentName + \"`.\");\n      }\n\n      return;\n    }\n\n    var propValue = props[propName];\n    var propType = typeof propValue;\n    var locationName = location || '(unknown)';\n\n    if (propType !== 'object') {\n      invariant(false, \"Invalid \" + locationName + \" `\" + propName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n    }\n\n    var allKeys = _objectSpread(_objectSpread({}, props[propName]), shapeTypes);\n\n    for (var _len = arguments.length, rest = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n      rest[_key - 5] = arguments[_key];\n    }\n\n    for (var _key2 in allKeys) {\n      var checker = shapeTypes[_key2];\n\n      if (!checker) {\n        invariant(false, \"Invalid props.\" + propName + \" key `\" + _key2 + \"` supplied to `\" + componentName + \"`.\" + '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));\n      }\n\n      var error = checker.apply(void 0, [propValue, _key2, componentName, location].concat(rest));\n\n      if (error) {\n        invariant(false, error.message + '\\nBad object: ' + JSON.stringify(props[propName], null, '  '));\n      }\n    }\n  }\n\n  function chainedCheckType(props, propName, componentName, location) {\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 4 ? _len2 - 4 : 0), _key3 = 4; _key3 < _len2; _key3++) {\n      rest[_key3 - 4] = arguments[_key3];\n    }\n\n    return checkType.apply(void 0, [false, props, propName, componentName, location].concat(rest));\n  }\n\n  chainedCheckType.isRequired = checkType.bind(null, true);\n  return chainedCheckType;\n}\n\nexport default createStrictShapeTypeChecker;","map":{"version":3,"sources":["/home/swapnil/Downloads/Instagram-master (2)/node_modules/react-native-web/src/modules/createStrictShapeTypeChecker/index.js"],"names":["invariant","createStrictShapeTypeChecker","shapeTypes","checkType","isRequired","props","propName","componentName","location","propValue","propType","locationName","allKeys","rest","key","checker","JSON","stringify","Object","keys","error","message","chainedCheckType","bind"],"mappings":";;;;;;AASA,OAAOA,SAAP,MAAsB,oBAAtB;;AAEA,SAASC,4BAAT,CAAsCC,UAAtC,EAEmC;AACjC,WAASC,SAAT,CAAmBC,UAAnB,EAA+BC,KAA/B,EAAsCC,QAAtC,EAAgDC,aAAhD,EAA+DC,QAA/D,EAAmF;AACjF,QAAI,CAACH,KAAK,CAACC,QAAD,CAAV,EAAsB;AACpB,UAAIF,UAAJ,EAAgB;AACdJ,QAAAA,SAAS,CACP,KADO,wBAEcM,QAFd,gCAEmDC,aAFnD,QAAT;AAID;;AACD;AACD;;AACD,QAAME,SAAS,GAAGJ,KAAK,CAACC,QAAD,CAAvB;AACA,QAAMI,QAAQ,GAAG,OAAOD,SAAxB;AACA,QAAME,YAAY,GAAGH,QAAQ,IAAI,WAAjC;;AACA,QAAIE,QAAQ,KAAK,QAAjB,EAA2B;AACzBV,MAAAA,SAAS,CACP,KADO,EAEP,aAAWW,YAAX,UAA6BL,QAA7B,mBAAqDI,QAArD,6BACmBH,aADnB,2BAFO,CAAT;AAKD;;AAGD,QAAMK,OAAO,mCAAQP,KAAK,CAACC,QAAD,CAAb,GAA4BJ,UAA5B,CAAb;;AAtBiF,sCAANW,IAAM;AAANA,MAAAA,IAAM;AAAA;;AAuBjF,SAAK,IAAMC,KAAX,IAAkBF,OAAlB,EAA2B;AACzB,UAAMG,OAAO,GAAGb,UAAU,CAACY,KAAD,CAA1B;;AACA,UAAI,CAACC,OAAL,EAAc;AACZf,QAAAA,SAAS,CACP,KADO,EAEP,mBAAiBM,QAAjB,cAAmCQ,KAAnC,uBAA0DP,aAA1D,UACE,gBADF,GAEES,IAAI,CAACC,SAAL,CAAeZ,KAAK,CAACC,QAAD,CAApB,EAAgC,IAAhC,EAAsC,IAAtC,CAFF,GAGE,gBAHF,GAIEU,IAAI,CAACC,SAAL,CAAeC,MAAM,CAACC,IAAP,CAAYjB,UAAZ,CAAf,EAAwC,IAAxC,EAA8C,IAA9C,CANK,CAAT;AAQD;;AACD,UAAMkB,KAAK,GAAGL,OAAO,MAAP,UAAQN,SAAR,EAAmBK,KAAnB,EAAwBP,aAAxB,EAAuCC,QAAvC,SAAoDK,IAApD,EAAd;;AACA,UAAIO,KAAJ,EAAW;AACTpB,QAAAA,SAAS,CACP,KADO,EAEPoB,KAAK,CAACC,OAAN,GAAgB,gBAAhB,GAAmCL,IAAI,CAACC,SAAL,CAAeZ,KAAK,CAACC,QAAD,CAApB,EAAgC,IAAhC,EAAsC,IAAtC,CAF5B,CAAT;AAID;AACF;AACF;;AACD,WAASgB,gBAAT,CACEjB,KADF,EAEEC,QAFF,EAGEC,aAHF,EAIEC,QAJF,EAMU;AAAA,uCADLK,IACK;AADLA,MAAAA,IACK;AAAA;;AACR,WAAOV,SAAS,MAAT,UAAU,KAAV,EAAiBE,KAAjB,EAAwBC,QAAxB,EAAkCC,aAAlC,EAAiDC,QAAjD,SAA8DK,IAA9D,EAAP;AACD;;AACDS,EAAAA,gBAAgB,CAAClB,UAAjB,GAA8BD,SAAS,CAACoB,IAAV,CAAe,IAAf,EAAqB,IAArB,CAA9B;AACA,SAAOD,gBAAP;AACD;;AAED,eAAerB,4BAAf","sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport invariant from 'fbjs/lib/invariant';\n\nfunction createStrictShapeTypeChecker(shapeTypes: {\n  [key: string]: ReactPropsCheckType\n}): ReactPropsChainableTypeChecker {\n  function checkType(isRequired, props, propName, componentName, location?, ...rest) {\n    if (!props[propName]) {\n      if (isRequired) {\n        invariant(\n          false,\n          `Required object \\`${propName}\\` was not specified in \\`${componentName}\\`.`\n        );\n      }\n      return;\n    }\n    const propValue = props[propName];\n    const propType = typeof propValue;\n    const locationName = location || '(unknown)';\n    if (propType !== 'object') {\n      invariant(\n        false,\n        `Invalid ${locationName} \\`${propName}\\` of type \\`${propType}\\` ` +\n          `supplied to \\`${componentName}\\`, expected \\`object\\`.`\n      );\n    }\n    // We need to check all keys in case some are required but missing from\n    // props.\n    const allKeys = { ...props[propName], ...shapeTypes };\n    for (const key in allKeys) {\n      const checker = shapeTypes[key];\n      if (!checker) {\n        invariant(\n          false,\n          `Invalid props.${propName} key \\`${key}\\` supplied to \\`${componentName}\\`.` +\n            '\\nBad object: ' +\n            JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +\n            JSON.stringify(Object.keys(shapeTypes), null, '  ')\n        );\n      }\n      const error = checker(propValue, key, componentName, location, ...rest);\n      if (error) {\n        invariant(\n          false,\n          error.message + '\\nBad object: ' + JSON.stringify(props[propName], null, '  ')\n        );\n      }\n    }\n  }\n  function chainedCheckType(\n    props: { [key: string]: any },\n    propName: string,\n    componentName: string,\n    location?: string,\n    ...rest\n  ): ?Error {\n    return checkType(false, props, propName, componentName, location, ...rest);\n  }\n  chainedCheckType.isRequired = checkType.bind(null, true);\n  return chainedCheckType;\n}\n\nexport default createStrictShapeTypeChecker;\n"]},"metadata":{},"sourceType":"module"}